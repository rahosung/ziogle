import {
  nanoid
} from "./chunk-HNIHZSAY.js";
import {
  EventManager,
  RateLimitedQueue,
  UploaderPlugin,
  emitSocketProgress_default,
  filterFilesToEmitUploadStarted,
  filterNonFailedFiles,
  getSocketHost,
  internalRateLimitedQueue,
  isNetworkError_default
} from "./chunk-RQNNSFV7.js";
import {
  NetworkError_default,
  Provider,
  RequestClient,
  UppySocket
} from "./chunk-7MJASB4X.js";
import "./chunk-LRULGENU.js";

// node_modules/@uppy/utils/lib/ProgressTimeout.js
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id = 0;
function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}
var _aliveTimer = _classPrivateFieldLooseKey("aliveTimer");
var _isDone = _classPrivateFieldLooseKey("isDone");
var _onTimedOut = _classPrivateFieldLooseKey("onTimedOut");
var _timeout = _classPrivateFieldLooseKey("timeout");
var ProgressTimeout = class {
  constructor(timeout, timeoutHandler) {
    Object.defineProperty(this, _aliveTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isDone, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _onTimedOut, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _timeout, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _timeout)[_timeout] = timeout;
    _classPrivateFieldLooseBase(this, _onTimedOut)[_onTimedOut] = timeoutHandler;
  }
  progress() {
    if (_classPrivateFieldLooseBase(this, _isDone)[_isDone])
      return;
    if (_classPrivateFieldLooseBase(this, _timeout)[_timeout] > 0) {
      clearTimeout(_classPrivateFieldLooseBase(this, _aliveTimer)[_aliveTimer]);
      _classPrivateFieldLooseBase(this, _aliveTimer)[_aliveTimer] = setTimeout(_classPrivateFieldLooseBase(this, _onTimedOut)[_onTimedOut], _classPrivateFieldLooseBase(this, _timeout)[_timeout]);
    }
  }
  done() {
    if (!_classPrivateFieldLooseBase(this, _isDone)[_isDone]) {
      clearTimeout(_classPrivateFieldLooseBase(this, _aliveTimer)[_aliveTimer]);
      _classPrivateFieldLooseBase(this, _aliveTimer)[_aliveTimer] = null;
      _classPrivateFieldLooseBase(this, _isDone)[_isDone] = true;
    }
  }
};
var ProgressTimeout_default = ProgressTimeout;

// node_modules/@uppy/xhr-upload/lib/locale.js
var locale_default = {
  strings: {
    // Shown in the Informer if an upload is being canceled because it stalled for too long.
    uploadStalled: "Upload has not made any progress for %{seconds} seconds. You may want to retry it."
  }
};

// node_modules/@uppy/xhr-upload/lib/index.js
function _classPrivateFieldLooseBase2(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id2 = 0;
function _classPrivateFieldLooseKey2(name) {
  return "__private_" + id2++ + "_" + name;
}
var packageJson = {
  "version": "3.3.2"
};
function buildResponseError(xhr, err) {
  let error = err;
  if (!error)
    error = new Error("Upload error");
  if (typeof error === "string")
    error = new Error(error);
  if (!(error instanceof Error)) {
    error = Object.assign(new Error("Upload error"), {
      data: error
    });
  }
  if (isNetworkError_default(xhr)) {
    error = new NetworkError_default(error, xhr);
    return error;
  }
  error.request = xhr;
  return error;
}
function setTypeInBlob(file) {
  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);
  return dataWithUpdatedType;
}
var _upload = _classPrivateFieldLooseKey2("upload");
var _requestSocketToken = _classPrivateFieldLooseKey2("requestSocketToken");
var _uploadBundle = _classPrivateFieldLooseKey2("uploadBundle");
var _uploadFiles = _classPrivateFieldLooseKey2("uploadFiles");
var _handleUpload = _classPrivateFieldLooseKey2("handleUpload");
var XHRUpload = class extends UploaderPlugin {
  constructor(uppy, _opts) {
    super(uppy, _opts);
    Object.defineProperty(this, _uploadFiles, {
      value: _uploadFiles2
    });
    Object.defineProperty(this, _uploadBundle, {
      value: _uploadBundle2
    });
    Object.defineProperty(this, _upload, {
      value: _upload2
    });
    Object.defineProperty(this, _requestSocketToken, {
      writable: true,
      value: async (file, options) => {
        const opts = this.getOptions(file);
        const Client = file.remote.providerOptions.provider ? Provider : RequestClient;
        const client = new Client(this.uppy, file.remote.providerOptions);
        const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(file.meta);
        const res = await client.post(file.remote.url, {
          ...file.remote.body,
          protocol: "multipart",
          endpoint: opts.endpoint,
          size: file.data.size,
          fieldname: opts.fieldName,
          metadata: Object.fromEntries(allowedMetaFields.map((name) => [name, file.meta[name]])),
          httpMethod: opts.method,
          useFormData: opts.formData,
          headers: typeof opts.headers === "function" ? opts.headers(file) : opts.headers
        }, options);
        return res.token;
      }
    });
    Object.defineProperty(this, _handleUpload, {
      writable: true,
      value: async (fileIDs) => {
        if (fileIDs.length === 0) {
          this.uppy.log("[XHRUpload] No files to upload!");
          return;
        }
        if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {
          this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning");
        }
        this.uppy.log("[XHRUpload] Uploading...");
        const files = this.uppy.getFilesByIds(fileIDs);
        const filesFiltered = filterNonFailedFiles(files);
        const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);
        this.uppy.emit("upload-start", filesToEmit);
        if (this.opts.bundle) {
          const isSomeFileRemote = filesFiltered.some((file) => file.isRemote);
          if (isSomeFileRemote) {
            throw new Error("Canâ€™t upload remote files when the `bundle: true` option is set");
          }
          if (typeof this.opts.headers === "function") {
            throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");
          }
          await _classPrivateFieldLooseBase2(this, _uploadBundle)[_uploadBundle](filesFiltered);
        } else {
          await _classPrivateFieldLooseBase2(this, _uploadFiles)[_uploadFiles](filesFiltered);
        }
      }
    });
    this.type = "uploader";
    this.id = this.opts.id || "XHRUpload";
    this.title = "XHRUpload";
    this.defaultLocale = locale_default;
    const defaultOptions = {
      formData: true,
      fieldName: _opts.bundle ? "files[]" : "file",
      method: "POST",
      allowedMetaFields: null,
      responseUrlFieldName: "url",
      bundle: false,
      headers: {},
      timeout: 30 * 1e3,
      limit: 5,
      withCredentials: false,
      responseType: "",
      /**
       * @param {string} responseText the response body string
       */
      getResponseData(responseText) {
        let parsedResponse = {};
        try {
          parsedResponse = JSON.parse(responseText);
        } catch (err) {
          uppy.log(err);
        }
        return parsedResponse;
      },
      /**
       *
       * @param {string} _ the response body string
       * @param {XMLHttpRequest | respObj} response the response object (XHR or similar)
       */
      getResponseError(_, response) {
        let error = new Error("Upload error");
        if (isNetworkError_default(response)) {
          error = new NetworkError_default(error, response);
        }
        return error;
      },
      /**
       * Check if the response from the upload endpoint indicates that the upload was successful.
       *
       * @param {number} status the response status code
       */
      validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    this.opts = {
      ...defaultOptions,
      ..._opts
    };
    this.i18nInit();
    if (internalRateLimitedQueue in this.opts) {
      this.requests = this.opts[internalRateLimitedQueue];
    } else {
      this.requests = new RateLimitedQueue(this.opts.limit);
    }
    if (this.opts.bundle && !this.opts.formData) {
      throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");
    }
    if ((_opts == null ? void 0 : _opts.allowedMetaFields) === void 0 && "metaFields" in this.opts) {
      throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`.");
    }
    this.uploaderEvents = /* @__PURE__ */ Object.create(null);
    this.setQueueRequestSocketToken(this.requests.wrapPromiseFunction(_classPrivateFieldLooseBase2(this, _requestSocketToken)[_requestSocketToken], {
      priority: -1
    }));
  }
  getOptions(file) {
    const overrides = this.uppy.getState().xhrUpload;
    const {
      headers
    } = this.opts;
    const opts = {
      ...this.opts,
      ...overrides || {},
      ...file.xhrUpload || {},
      headers: {}
    };
    if (typeof headers === "function") {
      opts.headers = headers(file);
    } else {
      Object.assign(opts.headers, this.opts.headers);
    }
    if (overrides) {
      Object.assign(opts.headers, overrides.headers);
    }
    if (file.xhrUpload) {
      Object.assign(opts.headers, file.xhrUpload.headers);
    }
    return opts;
  }
  // eslint-disable-next-line class-methods-use-this
  addMetadata(formData, meta, opts) {
    const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(meta);
    allowedMetaFields.forEach((item) => {
      if (Array.isArray(meta[item])) {
        meta[item].forEach((subItem) => formData.append(item, subItem));
      } else {
        formData.append(item, meta[item]);
      }
    });
  }
  createFormDataUpload(file, opts) {
    const formPost = new FormData();
    this.addMetadata(formPost, file.meta, opts);
    const dataWithUpdatedType = setTypeInBlob(file);
    if (file.name) {
      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);
    } else {
      formPost.append(opts.fieldName, dataWithUpdatedType);
    }
    return formPost;
  }
  createBundledUpload(files, opts) {
    const formPost = new FormData();
    const {
      meta
    } = this.uppy.getState();
    this.addMetadata(formPost, meta, opts);
    files.forEach((file) => {
      const options = this.getOptions(file);
      const dataWithUpdatedType = setTypeInBlob(file);
      if (file.name) {
        formPost.append(options.fieldName, dataWithUpdatedType, file.name);
      } else {
        formPost.append(options.fieldName, dataWithUpdatedType);
      }
    });
    return formPost;
  }
  async connectToServerSocket(file) {
    return new Promise((resolve, reject) => {
      const opts = this.getOptions(file);
      const token = file.serverToken;
      const host = getSocketHost(file.remote.companionUrl);
      let socket;
      const createSocket = () => {
        if (socket != null)
          return;
        socket = new UppySocket({
          target: `${host}/api/${token}`
        });
        socket.on("progress", (progressData) => emitSocketProgress_default(this, progressData, file));
        socket.on("success", (data) => {
          const body = opts.getResponseData(data.response.responseText, data.response);
          const uploadURL = body[opts.responseUrlFieldName];
          const uploadResp = {
            status: data.response.status,
            body,
            uploadURL
          };
          this.uppy.emit("upload-success", file, uploadResp);
          queuedRequest.done();
          socket.close();
          if (this.uploaderEvents[file.id]) {
            this.uploaderEvents[file.id].remove();
            this.uploaderEvents[file.id] = null;
          }
          return resolve();
        });
        socket.on("error", (errData) => {
          const resp = errData.response;
          const error = resp ? opts.getResponseError(resp.responseText, resp) : Object.assign(new Error(errData.error.message), {
            cause: errData.error
          });
          this.uppy.emit("upload-error", file, error);
          queuedRequest.done();
          socket.close();
          if (this.uploaderEvents[file.id]) {
            this.uploaderEvents[file.id].remove();
            this.uploaderEvents[file.id] = null;
          }
          reject(error);
        });
      };
      this.uploaderEvents[file.id] = new EventManager(this.uppy);
      let queuedRequest = this.requests.run(() => {
        if (file.isPaused) {
          var _socket;
          (_socket = socket) == null ? void 0 : _socket.send("pause", {});
        } else {
          createSocket();
        }
        return () => {
        };
      });
      this.onFileRemove(file.id, () => {
        var _socket2;
        (_socket2 = socket) == null ? void 0 : _socket2.send("cancel", {});
        socket.close();
        queuedRequest.abort();
        resolve(`upload ${file.id} was removed`);
      });
      this.onCancelAll(file.id, function(_temp) {
        let {
          reason
        } = _temp === void 0 ? {} : _temp;
        if (reason === "user") {
          var _socket3;
          (_socket3 = socket) == null ? void 0 : _socket3.send("cancel", {});
          queuedRequest.abort();
        }
        resolve(`upload ${file.id} was canceled`);
      });
      const onRetryRequest = () => {
        if (socket == null) {
          queuedRequest.abort();
        } else {
          queuedRequest.done();
        }
        queuedRequest = this.requests.run(() => {
          if (socket == null) {
            createSocket();
          }
          return () => {
          };
        });
      };
      this.onRetry(file.id, onRetryRequest);
      this.onRetryAll(file.id, onRetryRequest);
    }).catch((err) => {
      this.uppy.emit("upload-error", file, err);
      return Promise.reject(err);
    });
  }
  onFileRemove(fileID, cb) {
    this.uploaderEvents[fileID].on("file-removed", (file) => {
      if (fileID === file.id)
        cb(file.id);
    });
  }
  onRetry(fileID, cb) {
    this.uploaderEvents[fileID].on("upload-retry", (targetFileID) => {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  onRetryAll(fileID, cb) {
    this.uploaderEvents[fileID].on("retry-all", () => {
      if (!this.uppy.getFile(fileID))
        return;
      cb();
    });
  }
  onCancelAll(fileID, eventHandler) {
    var _this = this;
    this.uploaderEvents[fileID].on("cancel-all", function() {
      if (!_this.uppy.getFile(fileID))
        return;
      eventHandler(...arguments);
    });
  }
  install() {
    if (this.opts.bundle) {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: false
        }
      });
    }
    this.uppy.addUploader(_classPrivateFieldLooseBase2(this, _handleUpload)[_handleUpload]);
  }
  uninstall() {
    if (this.opts.bundle) {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: true
        }
      });
    }
    this.uppy.removeUploader(_classPrivateFieldLooseBase2(this, _handleUpload)[_handleUpload]);
  }
};
async function _upload2(file, current, total) {
  const opts = this.getOptions(file);
  this.uppy.log(`uploading ${current} of ${total}`);
  return new Promise((resolve, reject) => {
    const data = opts.formData ? this.createFormDataUpload(file, opts) : file.data;
    const xhr = new XMLHttpRequest();
    this.uploaderEvents[file.id] = new EventManager(this.uppy);
    let queuedRequest;
    const timer = new ProgressTimeout_default(opts.timeout, () => {
      const error = new Error(this.i18n("uploadStalled", {
        seconds: Math.ceil(opts.timeout / 1e3)
      }));
      this.uppy.emit("upload-stalled", error, [file]);
    });
    const id3 = nanoid();
    xhr.upload.addEventListener("loadstart", () => {
      this.uppy.log(`[XHRUpload] ${id3} started`);
    });
    xhr.upload.addEventListener("progress", (ev) => {
      this.uppy.log(`[XHRUpload] ${id3} progress: ${ev.loaded} / ${ev.total}`);
      timer.progress();
      if (ev.lengthComputable) {
        this.uppy.emit("upload-progress", file, {
          uploader: this,
          bytesUploaded: ev.loaded,
          bytesTotal: ev.total
        });
      }
    });
    xhr.addEventListener("load", () => {
      this.uppy.log(`[XHRUpload] ${id3} finished`);
      timer.done();
      queuedRequest.done();
      if (this.uploaderEvents[file.id]) {
        this.uploaderEvents[file.id].remove();
        this.uploaderEvents[file.id] = null;
      }
      if (opts.validateStatus(xhr.status, xhr.responseText, xhr)) {
        const body2 = opts.getResponseData(xhr.responseText, xhr);
        const uploadURL = body2[opts.responseUrlFieldName];
        const uploadResp = {
          status: xhr.status,
          body: body2,
          uploadURL
        };
        this.uppy.emit("upload-success", file, uploadResp);
        if (uploadURL) {
          this.uppy.log(`Download ${file.name} from ${uploadURL}`);
        }
        return resolve(file);
      }
      const body = opts.getResponseData(xhr.responseText, xhr);
      const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
      const response = {
        status: xhr.status,
        body
      };
      this.uppy.emit("upload-error", file, error, response);
      return reject(error);
    });
    xhr.addEventListener("error", () => {
      this.uppy.log(`[XHRUpload] ${id3} errored`);
      timer.done();
      queuedRequest.done();
      if (this.uploaderEvents[file.id]) {
        this.uploaderEvents[file.id].remove();
        this.uploaderEvents[file.id] = null;
      }
      const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
      this.uppy.emit("upload-error", file, error);
      return reject(error);
    });
    xhr.open(opts.method.toUpperCase(), opts.endpoint, true);
    xhr.withCredentials = opts.withCredentials;
    if (opts.responseType !== "") {
      xhr.responseType = opts.responseType;
    }
    queuedRequest = this.requests.run(() => {
      const currentOpts = this.getOptions(file);
      Object.keys(currentOpts.headers).forEach((header) => {
        xhr.setRequestHeader(header, currentOpts.headers[header]);
      });
      xhr.send(data);
      return () => {
        timer.done();
        xhr.abort();
      };
    });
    this.onFileRemove(file.id, () => {
      queuedRequest.abort();
      reject(new Error("File removed"));
    });
    this.onCancelAll(file.id, (_ref) => {
      let {
        reason
      } = _ref;
      if (reason === "user") {
        queuedRequest.abort();
      }
      reject(new Error("Upload cancelled"));
    });
  });
}
function _uploadBundle2(files) {
  return new Promise((resolve, reject) => {
    const {
      endpoint
    } = this.opts;
    const {
      method
    } = this.opts;
    const optsFromState = this.uppy.getState().xhrUpload;
    const formData = this.createBundledUpload(files, {
      ...this.opts,
      ...optsFromState || {}
    });
    const xhr = new XMLHttpRequest();
    const emitError = (error) => {
      files.forEach((file) => {
        this.uppy.emit("upload-error", file, error);
      });
    };
    const timer = new ProgressTimeout_default(this.opts.timeout, () => {
      const error = new Error(this.i18n("uploadStalled", {
        seconds: Math.ceil(this.opts.timeout / 1e3)
      }));
      this.uppy.emit("upload-stalled", error, files);
    });
    xhr.upload.addEventListener("loadstart", () => {
      this.uppy.log("[XHRUpload] started uploading bundle");
      timer.progress();
    });
    xhr.upload.addEventListener("progress", (ev) => {
      timer.progress();
      if (!ev.lengthComputable)
        return;
      files.forEach((file) => {
        this.uppy.emit("upload-progress", file, {
          uploader: this,
          bytesUploaded: ev.loaded / ev.total * file.size,
          bytesTotal: file.size
        });
      });
    });
    xhr.addEventListener("load", (ev) => {
      timer.done();
      if (this.opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {
        const body = this.opts.getResponseData(xhr.responseText, xhr);
        const uploadResp = {
          status: ev.target.status,
          body
        };
        files.forEach((file) => {
          this.uppy.emit("upload-success", file, uploadResp);
        });
        return resolve();
      }
      const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error("Upload error");
      error.request = xhr;
      emitError(error);
      return reject(error);
    });
    xhr.addEventListener("error", () => {
      timer.done();
      const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error("Upload error");
      emitError(error);
      return reject(error);
    });
    this.uppy.on("cancel-all", function(_temp2) {
      let {
        reason
      } = _temp2 === void 0 ? {} : _temp2;
      if (reason !== "user")
        return;
      timer.done();
      xhr.abort();
    });
    xhr.open(method.toUpperCase(), endpoint, true);
    xhr.withCredentials = this.opts.withCredentials;
    if (this.opts.responseType !== "") {
      xhr.responseType = this.opts.responseType;
    }
    Object.keys(this.opts.headers).forEach((header) => {
      xhr.setRequestHeader(header, this.opts.headers[header]);
    });
    xhr.send(formData);
  });
}
async function _uploadFiles2(files) {
  await Promise.allSettled(files.map((file, i) => {
    const current = parseInt(i, 10) + 1;
    const total = files.length;
    if (file.isRemote) {
      const controller = new AbortController();
      const removedHandler = (removedFile) => {
        if (removedFile.id === file.id)
          controller.abort();
      };
      this.uppy.on("file-removed", removedHandler);
      const uploadPromise = this.uploadRemoteFile(file, {
        signal: controller.signal
      });
      this.requests.wrapSyncFunction(() => {
        this.uppy.off("file-removed", removedHandler);
      }, {
        priority: -1
      })();
      return uploadPromise;
    }
    return _classPrivateFieldLooseBase2(this, _upload)[_upload](file, current, total);
  }));
}
XHRUpload.VERSION = packageJson.version;
export {
  XHRUpload as default
};
//# sourceMappingURL=@uppy_xhr-upload.js.map
