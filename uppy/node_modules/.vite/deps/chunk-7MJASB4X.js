import {
  __export,
  __toESM,
  has,
  require_namespace_emitter
} from "./chunk-LRULGENU.js";

// node_modules/@uppy/utils/lib/NetworkError.js
var NetworkError = class extends Error {
  constructor(error, xhr) {
    if (xhr === void 0) {
      xhr = null;
    }
    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
    this.cause = error;
    this.isNetworkError = true;
    this.request = xhr;
  }
};
var NetworkError_default = NetworkError;

// node_modules/@uppy/utils/lib/fetchWithNetworkError.js
function fetchWithNetworkError() {
  return fetch(...arguments).catch((err) => {
    if (err.name === "AbortError") {
      throw err;
    } else {
      throw new NetworkError_default(err);
    }
  });
}

// node_modules/@uppy/utils/lib/ErrorWithCause.js
var ErrorWithCause = class extends Error {
  constructor(message, options) {
    if (options === void 0) {
      options = {};
    }
    super(message);
    this.cause = options.cause;
    if (this.cause && has(this.cause, "isNetworkError")) {
      this.isNetworkError = this.cause.isNetworkError;
    }
  }
};
var ErrorWithCause_default = ErrorWithCause;

// node_modules/@uppy/companion-client/lib/AuthError.js
var AuthError = class extends Error {
  constructor() {
    super("Authorization required");
    this.name = "AuthError";
    this.isAuthError = true;
  }
};
var AuthError_default = AuthError;

// node_modules/@uppy/companion-client/lib/RequestClient.js
var _Symbol$for;
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id = 0;
function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}
var packageJson = {
  "version": "3.3.0"
};
function stripSlash(url) {
  return url.replace(/\/$/, "");
}
async function handleJSONResponse(res) {
  if (res.status === 401) {
    throw new AuthError_default();
  }
  const jsonPromise = res.json();
  if (res.ok) {
    return jsonPromise;
  }
  let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;
  try {
    const errData = await jsonPromise;
    errMsg = errData.message ? `${errMsg} message: ${errData.message}` : errMsg;
    errMsg = errData.requestId ? `${errMsg} request-Id: ${errData.requestId}` : errMsg;
  } catch {
  }
  throw new Error(errMsg);
}
var allowedHeadersCache = /* @__PURE__ */ new Map();
var _companionHeaders = _classPrivateFieldLooseKey("companionHeaders");
var _getUrl = _classPrivateFieldLooseKey("getUrl");
_Symbol$for = Symbol.for("uppy test: getCompanionHeaders");
var RequestClient = class _RequestClient {
  constructor(uppy, opts) {
    Object.defineProperty(this, _getUrl, {
      value: _getUrl2
    });
    Object.defineProperty(this, _companionHeaders, {
      writable: true,
      value: void 0
    });
    this.uppy = uppy;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders] = opts == null ? void 0 : opts.companionHeaders;
  }
  setCompanionHeaders(headers) {
    _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders] = headers;
  }
  [_Symbol$for]() {
    return _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders];
  }
  get hostname() {
    const {
      companion
    } = this.uppy.getState();
    const host = this.opts.companionUrl;
    return stripSlash(companion && companion[host] ? companion[host] : host);
  }
  async headers() {
    const defaultHeaders = {
      Accept: "application/json",
      "Content-Type": "application/json",
      "Uppy-Versions": `@uppy/companion-client=${_RequestClient.VERSION}`
    };
    return {
      ...defaultHeaders,
      ..._classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders]
    };
  }
  onReceiveResponse(_ref) {
    let {
      headers
    } = _ref;
    const state = this.uppy.getState();
    const companion = state.companion || {};
    const host = this.opts.companionUrl;
    if (headers.has("i-am") && headers.get("i-am") !== companion[host]) {
      this.uppy.setState({
        companion: {
          ...companion,
          [host]: headers.get("i-am")
        }
      });
    }
  }
  /*
    Preflight was added to avoid breaking change between older Companion-client versions and
    newer Companion versions and vice-versa. Usually the break will manifest via CORS errors because a
    version of companion-client could be sending certain headers to a version of Companion server that
    does not support those headers. In which case, the default preflight would lead to CORS.
    So to avoid those errors, we do preflight ourselves, to see what headers the Companion server
    we are communicating with allows. And based on that, companion-client knows what headers to
    send and what headers to not send.
     The preflight only happens once throughout the life-cycle of a certain
    Companion-client <-> Companion-server pair (allowedHeadersCache).
    Subsequent requests use the cached result of the preflight.
    However if there is an error retrieving the allowed headers, we will try again next time
  */
  async preflight(path) {
    const allowedHeadersCached = allowedHeadersCache.get(this.hostname);
    if (allowedHeadersCached != null)
      return allowedHeadersCached;
    const fallbackAllowedHeaders = ["accept", "content-type", "uppy-auth-token"];
    const promise = (async () => {
      try {
        const response = await fetch(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
          method: "OPTIONS"
        });
        const header = response.headers.get("access-control-allow-headers");
        if (header == null || header === "*") {
          allowedHeadersCache.set(this.hostname, fallbackAllowedHeaders);
          return fallbackAllowedHeaders;
        }
        this.uppy.log(`[CompanionClient] adding allowed preflight headers to companion cache: ${this.hostname} ${header}`);
        const allowedHeaders = header.split(",").map((headerName) => headerName.trim().toLowerCase());
        allowedHeadersCache.set(this.hostname, allowedHeaders);
        return allowedHeaders;
      } catch (err) {
        this.uppy.log(`[CompanionClient] unable to make preflight request ${err}`, "warning");
        allowedHeadersCache.delete(this.hostname);
        return fallbackAllowedHeaders;
      }
    })();
    allowedHeadersCache.set(this.hostname, promise);
    return promise;
  }
  async preflightAndHeaders(path) {
    const [allowedHeaders, headers] = await Promise.all([this.preflight(path), this.headers()]);
    return Object.fromEntries(Object.entries(headers).filter((_ref2) => {
      let [header] = _ref2;
      if (!allowedHeaders.includes(header.toLowerCase())) {
        this.uppy.log(`[CompanionClient] excluding disallowed header ${header}`);
        return false;
      }
      return true;
    }));
  }
  /** @protected */
  async request(_ref3) {
    let {
      path,
      method = "GET",
      data,
      skipPostResponse,
      signal
    } = _ref3;
    try {
      const headers = await this.preflightAndHeaders(path);
      const response = await fetchWithNetworkError(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
        method,
        signal,
        headers,
        credentials: this.opts.companionCookiesRule || "same-origin",
        body: data ? JSON.stringify(data) : null
      });
      if (!skipPostResponse)
        this.onReceiveResponse(response);
      return handleJSONResponse(response);
    } catch (err) {
      if (err != null && err.isAuthError)
        throw err;
      throw new ErrorWithCause_default(`Could not ${method} ${_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path)}`, {
        cause: err
      });
    }
  }
  async get(path, options) {
    if (options === void 0) {
      options = void 0;
    }
    if (typeof options === "boolean")
      options = {
        skipPostResponse: options
      };
    return this.request({
      ...options,
      path
    });
  }
  async post(path, data, options) {
    if (options === void 0) {
      options = void 0;
    }
    if (typeof options === "boolean")
      options = {
        skipPostResponse: options
      };
    return this.request({
      ...options,
      path,
      method: "POST",
      data
    });
  }
  async delete(path, data, options) {
    if (data === void 0) {
      data = void 0;
    }
    if (typeof options === "boolean")
      options = {
        skipPostResponse: options
      };
    return this.request({
      ...options,
      path,
      method: "DELETE",
      data
    });
  }
};
function _getUrl2(url) {
  if (/^(https?:|)\/\//.test(url)) {
    return url;
  }
  return `${this.hostname}/${url}`;
}
RequestClient.VERSION = packageJson.version;

// node_modules/@uppy/companion-client/lib/tokenStorage.js
var tokenStorage_exports = {};
__export(tokenStorage_exports, {
  getItem: () => getItem,
  removeItem: () => removeItem,
  setItem: () => setItem
});
function setItem(key, value) {
  return new Promise((resolve) => {
    localStorage.setItem(key, value);
    resolve();
  });
}
function getItem(key) {
  return Promise.resolve(localStorage.getItem(key));
}
function removeItem(key) {
  return new Promise((resolve) => {
    localStorage.removeItem(key);
    resolve();
  });
}

// node_modules/@uppy/companion-client/lib/Provider.js
function _classPrivateFieldLooseBase2(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id2 = 0;
function _classPrivateFieldLooseKey2(name) {
  return "__private_" + id2++ + "_" + name;
}
var getName = (id4) => {
  return id4.split("-").map((s) => s.charAt(0).toUpperCase() + s.slice(1)).join(" ");
};
function getOrigin() {
  return location.origin;
}
function getRegex(value) {
  if (typeof value === "string") {
    return new RegExp(`^${value}$`);
  }
  if (value instanceof RegExp) {
    return value;
  }
  return void 0;
}
function isOriginAllowed(origin, allowedOrigin) {
  const patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(getRegex) : [getRegex(allowedOrigin)];
  return patterns.some((pattern) => (pattern == null ? void 0 : pattern.test(origin)) || (pattern == null ? void 0 : pattern.test(`${origin}/`)));
}
var _refreshingTokenPromise = _classPrivateFieldLooseKey2("refreshingTokenPromise");
var _getAuthToken = _classPrivateFieldLooseKey2("getAuthToken");
var _removeAuthToken = _classPrivateFieldLooseKey2("removeAuthToken");
var Provider = class extends RequestClient {
  constructor(uppy, opts) {
    super(uppy, opts);
    Object.defineProperty(this, _removeAuthToken, {
      value: _removeAuthToken2
    });
    Object.defineProperty(this, _getAuthToken, {
      value: _getAuthToken2
    });
    Object.defineProperty(this, _refreshingTokenPromise, {
      writable: true,
      value: void 0
    });
    this.provider = opts.provider;
    this.id = this.provider;
    this.name = this.opts.name || getName(this.id);
    this.pluginId = this.opts.pluginId;
    this.tokenKey = `companion-${this.pluginId}-auth-token`;
    this.companionKeysParams = this.opts.companionKeysParams;
    this.preAuthToken = null;
  }
  async headers() {
    const [headers, token] = await Promise.all([super.headers(), _classPrivateFieldLooseBase2(this, _getAuthToken)[_getAuthToken]()]);
    const authHeaders = {};
    if (token) {
      authHeaders["uppy-auth-token"] = token;
    }
    if (this.companionKeysParams) {
      authHeaders["uppy-credentials-params"] = btoa(JSON.stringify({
        params: this.companionKeysParams
      }));
    }
    return {
      ...headers,
      ...authHeaders
    };
  }
  onReceiveResponse(response) {
    super.onReceiveResponse(response);
    const plugin = this.uppy.getPlugin(this.pluginId);
    const oldAuthenticated = plugin.getPluginState().authenticated;
    const authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
    plugin.setPluginState({
      authenticated
    });
    return response;
  }
  async setAuthToken(token) {
    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
  }
  /**
   * Ensure we have a preauth token if necessary. Attempts to fetch one if we don't,
   * or rejects if loading one fails.
   */
  async ensurePreAuth() {
    if (this.companionKeysParams && !this.preAuthToken) {
      await this.fetchPreAuthToken();
      if (!this.preAuthToken) {
        throw new Error("Could not load authentication data required for third-party login. Please try again later.");
      }
    }
  }
  authUrl(queries) {
    if (queries === void 0) {
      queries = {};
    }
    const params = new URLSearchParams({
      state: btoa(JSON.stringify({
        origin: getOrigin()
      })),
      ...queries
    });
    if (this.preAuthToken) {
      params.set("uppyPreAuthToken", this.preAuthToken);
    }
    return `${this.hostname}/${this.id}/connect?${params}`;
  }
  async login(queries) {
    await this.ensurePreAuth();
    return new Promise((resolve, reject) => {
      const link = this.authUrl(queries);
      const authWindow = window.open(link, "_blank");
      const handleToken = (e) => {
        if (e.source !== authWindow) {
          this.uppy.log.warn("ignoring event from unknown source", e);
          return;
        }
        const {
          companionAllowedHosts
        } = this.uppy.getPlugin(this.pluginId).opts;
        if (!isOriginAllowed(e.origin, companionAllowedHosts)) {
          reject(new Error(`rejecting event from ${e.origin} vs allowed pattern ${companionAllowedHosts}`));
          return;
        }
        const data = typeof e.data === "string" ? JSON.parse(e.data) : e.data;
        if (data.error) {
          const {
            uppy
          } = this;
          const message = uppy.i18n("authAborted");
          uppy.info({
            message
          }, "warning", 5e3);
          reject(new Error("auth aborted"));
          return;
        }
        if (!data.token) {
          reject(new Error("did not receive token from auth window"));
          return;
        }
        authWindow.close();
        window.removeEventListener("message", handleToken);
        this.setAuthToken(data.token);
        resolve();
      };
      window.addEventListener("message", handleToken);
    });
  }
  refreshTokenUrl() {
    return `${this.hostname}/${this.id}/refresh-token`;
  }
  fileUrl(id4) {
    return `${this.hostname}/${this.id}/get/${id4}`;
  }
  /** @protected */
  async request() {
    await _classPrivateFieldLooseBase2(this, _refreshingTokenPromise)[_refreshingTokenPromise];
    try {
      return await super.request(...arguments);
    } catch (err) {
      if (!err.isAuthError)
        throw err;
      await _classPrivateFieldLooseBase2(this, _refreshingTokenPromise)[_refreshingTokenPromise];
      _classPrivateFieldLooseBase2(this, _refreshingTokenPromise)[_refreshingTokenPromise] = (async () => {
        try {
          const response = await super.request({
            path: this.refreshTokenUrl(),
            method: "POST"
          });
          await this.setAuthToken(response.uppyAuthToken);
        } finally {
          _classPrivateFieldLooseBase2(this, _refreshingTokenPromise)[_refreshingTokenPromise] = void 0;
        }
      })();
      await _classPrivateFieldLooseBase2(this, _refreshingTokenPromise)[_refreshingTokenPromise];
      return super.request(...arguments);
    }
  }
  async fetchPreAuthToken() {
    if (!this.companionKeysParams) {
      return;
    }
    try {
      const res = await this.post(`${this.id}/preauth/`, {
        params: this.companionKeysParams
      });
      this.preAuthToken = res.token;
    } catch (err) {
      this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${err}`, "warning");
    }
  }
  list(directory, options) {
    return this.get(`${this.id}/list/${directory || ""}`, options);
  }
  async logout(options) {
    const response = await this.get(`${this.id}/logout`, options);
    await _classPrivateFieldLooseBase2(this, _removeAuthToken)[_removeAuthToken]();
    return response;
  }
  static initPlugin(plugin, opts, defaultOpts) {
    plugin.type = "acquirer";
    plugin.files = [];
    if (defaultOpts) {
      plugin.opts = {
        ...defaultOpts,
        ...opts
      };
    }
    if (opts.serverUrl || opts.serverPattern) {
      throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");
    }
    if (opts.companionAllowedHosts) {
      const pattern = opts.companionAllowedHosts;
      if (typeof pattern !== "string" && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
        throw new TypeError(`${plugin.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);
      }
      plugin.opts.companionAllowedHosts = pattern;
    } else if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
      plugin.opts.companionAllowedHosts = `https://${opts.companionUrl.replace(/^\/\//, "")}`;
    } else {
      plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
    }
    plugin.storage = plugin.opts.storage || tokenStorage_exports;
  }
};
async function _getAuthToken2() {
  return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
}
async function _removeAuthToken2() {
  return this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey);
}

// node_modules/@uppy/companion-client/lib/Socket.js
var import_namespace_emitter = __toESM(require_namespace_emitter(), 1);
var _Symbol$for2;
var _Symbol$for22;
function _classPrivateFieldLooseBase3(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id3 = 0;
function _classPrivateFieldLooseKey3(name) {
  return "__private_" + id3++ + "_" + name;
}
var _queued = _classPrivateFieldLooseKey3("queued");
var _emitter = _classPrivateFieldLooseKey3("emitter");
var _isOpen = _classPrivateFieldLooseKey3("isOpen");
var _socket = _classPrivateFieldLooseKey3("socket");
var _handleMessage = _classPrivateFieldLooseKey3("handleMessage");
_Symbol$for2 = Symbol.for("uppy test: getSocket");
_Symbol$for22 = Symbol.for("uppy test: getQueued");
var UppySocket = class {
  constructor(opts) {
    Object.defineProperty(this, _queued, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _emitter, {
      writable: true,
      value: (0, import_namespace_emitter.default)()
    });
    Object.defineProperty(this, _isOpen, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _socket, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handleMessage, {
      writable: true,
      value: (e) => {
        try {
          const message = JSON.parse(e.data);
          this.emit(message.action, message.payload);
        } catch (err) {
          console.log(err);
        }
      }
    });
    this.opts = opts;
    if (!opts || opts.autoOpen !== false) {
      this.open();
    }
  }
  get isOpen() {
    return _classPrivateFieldLooseBase3(this, _isOpen)[_isOpen];
  }
  [_Symbol$for2]() {
    return _classPrivateFieldLooseBase3(this, _socket)[_socket];
  }
  [_Symbol$for22]() {
    return _classPrivateFieldLooseBase3(this, _queued)[_queued];
  }
  open() {
    if (_classPrivateFieldLooseBase3(this, _socket)[_socket] != null)
      return;
    _classPrivateFieldLooseBase3(this, _socket)[_socket] = new WebSocket(this.opts.target);
    _classPrivateFieldLooseBase3(this, _socket)[_socket].onopen = () => {
      _classPrivateFieldLooseBase3(this, _isOpen)[_isOpen] = true;
      while (_classPrivateFieldLooseBase3(this, _queued)[_queued].length > 0 && _classPrivateFieldLooseBase3(this, _isOpen)[_isOpen]) {
        const first = _classPrivateFieldLooseBase3(this, _queued)[_queued].shift();
        this.send(first.action, first.payload);
      }
    };
    _classPrivateFieldLooseBase3(this, _socket)[_socket].onclose = () => {
      _classPrivateFieldLooseBase3(this, _isOpen)[_isOpen] = false;
      _classPrivateFieldLooseBase3(this, _socket)[_socket] = null;
    };
    _classPrivateFieldLooseBase3(this, _socket)[_socket].onmessage = _classPrivateFieldLooseBase3(this, _handleMessage)[_handleMessage];
  }
  close() {
    var _classPrivateFieldLoo;
    (_classPrivateFieldLoo = _classPrivateFieldLooseBase3(this, _socket)[_socket]) == null ? void 0 : _classPrivateFieldLoo.close();
  }
  send(action, payload) {
    if (!_classPrivateFieldLooseBase3(this, _isOpen)[_isOpen]) {
      _classPrivateFieldLooseBase3(this, _queued)[_queued].push({
        action,
        payload
      });
      return;
    }
    _classPrivateFieldLooseBase3(this, _socket)[_socket].send(JSON.stringify({
      action,
      payload
    }));
  }
  on(action, handler) {
    _classPrivateFieldLooseBase3(this, _emitter)[_emitter].on(action, handler);
  }
  emit(action, payload) {
    _classPrivateFieldLooseBase3(this, _emitter)[_emitter].emit(action, payload);
  }
  once(action, handler) {
    _classPrivateFieldLooseBase3(this, _emitter)[_emitter].once(action, handler);
  }
};

export {
  NetworkError_default,
  RequestClient,
  Provider,
  UppySocket
};
//# sourceMappingURL=chunk-7MJASB4X.js.map
