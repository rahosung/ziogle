import {
  BasePlugin,
  __toESM,
  require_throttle
} from "./chunk-LRULGENU.js";

// node_modules/@uppy/core/lib/UploaderPlugin.js
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id = 0;
function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}
var _queueRequestSocketToken = _classPrivateFieldLooseKey("queueRequestSocketToken");
var UploaderPlugin = class extends BasePlugin {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, _queueRequestSocketToken, {
      writable: true,
      value: void 0
    });
  }
  /** @protected */
  setQueueRequestSocketToken(fn) {
    _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken] = fn;
  }
  async uploadRemoteFile(file, options) {
    if (options === void 0) {
      options = {};
    }
    try {
      if (file.serverToken) {
        return await this.connectToServerSocket(file);
      }
      const serverToken = await _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken](file).abortOn(options.signal);
      if (!this.uppy.getState().files[file.id])
        return void 0;
      this.uppy.setFileState(file.id, {
        serverToken
      });
      return await this.connectToServerSocket(this.uppy.getFile(file.id));
    } catch (err) {
      var _err$cause;
      if ((err == null || (_err$cause = err.cause) == null ? void 0 : _err$cause.name) === "AbortError") {
        return void 0;
      }
      this.uppy.setFileState(file.id, {
        serverToken: void 0
      });
      this.uppy.emit("upload-error", file, err);
      throw err;
    }
  }
};

// node_modules/@uppy/utils/lib/emitSocketProgress.js
var import_throttle = __toESM(require_throttle());
function emitSocketProgress(uploader, progressData, file) {
  const {
    progress,
    bytesUploaded,
    bytesTotal
  } = progressData;
  if (progress) {
    uploader.uppy.log(`Upload progress: ${progress}`);
    uploader.uppy.emit("upload-progress", file, {
      uploader,
      bytesUploaded,
      bytesTotal
    });
  }
}
var emitSocketProgress_default = (0, import_throttle.default)(emitSocketProgress, 300, {
  leading: true,
  trailing: true
});

// node_modules/@uppy/utils/lib/getSocketHost.js
function getSocketHost(url) {
  const regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
  const host = regex.exec(url)[1];
  const socketProtocol = /^http:\/\//i.test(url) ? "ws" : "wss";
  return `${socketProtocol}://${host}`;
}

// node_modules/@uppy/utils/lib/EventManager.js
function _classPrivateFieldLooseBase2(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id2 = 0;
function _classPrivateFieldLooseKey2(name) {
  return "__private_" + id2++ + "_" + name;
}
var _emitter = _classPrivateFieldLooseKey2("emitter");
var _events = _classPrivateFieldLooseKey2("events");
var EventManager = class {
  constructor(emitter) {
    Object.defineProperty(this, _emitter, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _events, {
      writable: true,
      value: []
    });
    _classPrivateFieldLooseBase2(this, _emitter)[_emitter] = emitter;
  }
  on(event, fn) {
    _classPrivateFieldLooseBase2(this, _events)[_events].push([event, fn]);
    return _classPrivateFieldLooseBase2(this, _emitter)[_emitter].on(event, fn);
  }
  remove() {
    for (const [event, fn] of _classPrivateFieldLooseBase2(this, _events)[_events].splice(0)) {
      _classPrivateFieldLooseBase2(this, _emitter)[_emitter].off(event, fn);
    }
  }
};

// node_modules/@uppy/utils/lib/isNetworkError.js
function isNetworkError(xhr) {
  if (!xhr) {
    return false;
  }
  return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
}
var isNetworkError_default = isNetworkError;

// node_modules/@uppy/utils/lib/RateLimitedQueue.js
function _classPrivateFieldLooseBase3(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id3 = 0;
function _classPrivateFieldLooseKey3(name) {
  return "__private_" + id3++ + "_" + name;
}
function createCancelError(cause) {
  return new Error("Cancelled", {
    cause
  });
}
function abortOn(signal) {
  if (signal != null) {
    var _this$then;
    const abortPromise = () => this.abort(signal.reason);
    signal.addEventListener("abort", abortPromise, {
      once: true
    });
    const removeAbortListener = () => {
      signal.removeEventListener("abort", abortPromise);
    };
    (_this$then = this.then) == null ? void 0 : _this$then.call(this, removeAbortListener, removeAbortListener);
  }
  return this;
}
var _activeRequests = _classPrivateFieldLooseKey3("activeRequests");
var _queuedHandlers = _classPrivateFieldLooseKey3("queuedHandlers");
var _paused = _classPrivateFieldLooseKey3("paused");
var _pauseTimer = _classPrivateFieldLooseKey3("pauseTimer");
var _downLimit = _classPrivateFieldLooseKey3("downLimit");
var _upperLimit = _classPrivateFieldLooseKey3("upperLimit");
var _rateLimitingTimer = _classPrivateFieldLooseKey3("rateLimitingTimer");
var _call = _classPrivateFieldLooseKey3("call");
var _queueNext = _classPrivateFieldLooseKey3("queueNext");
var _next = _classPrivateFieldLooseKey3("next");
var _queue = _classPrivateFieldLooseKey3("queue");
var _dequeue = _classPrivateFieldLooseKey3("dequeue");
var _resume = _classPrivateFieldLooseKey3("resume");
var _increaseLimit = _classPrivateFieldLooseKey3("increaseLimit");
var RateLimitedQueue = class {
  constructor(limit) {
    Object.defineProperty(this, _dequeue, {
      value: _dequeue2
    });
    Object.defineProperty(this, _queue, {
      value: _queue2
    });
    Object.defineProperty(this, _next, {
      value: _next2
    });
    Object.defineProperty(this, _queueNext, {
      value: _queueNext2
    });
    Object.defineProperty(this, _call, {
      value: _call2
    });
    Object.defineProperty(this, _activeRequests, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _queuedHandlers, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _paused, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _pauseTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _downLimit, {
      writable: true,
      value: 1
    });
    Object.defineProperty(this, _upperLimit, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _rateLimitingTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _resume, {
      writable: true,
      value: () => this.resume()
    });
    Object.defineProperty(this, _increaseLimit, {
      writable: true,
      value: () => {
        if (_classPrivateFieldLooseBase3(this, _paused)[_paused]) {
          _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], 0);
          return;
        }
        _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] = this.limit;
        this.limit = Math.ceil((_classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit]) / 2);
        for (let i = _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit]; i <= this.limit; i++) {
          _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
        }
        if (_classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] > 3) {
          _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], 2e3);
        } else {
          _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] / 2);
        }
      }
    });
    if (typeof limit !== "number" || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }
  }
  run(fn, queueOptions) {
    if (!_classPrivateFieldLooseBase3(this, _paused)[_paused] && _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] < this.limit) {
      return _classPrivateFieldLooseBase3(this, _call)[_call](fn);
    }
    return _classPrivateFieldLooseBase3(this, _queue)[_queue](fn, queueOptions);
  }
  wrapSyncFunction(fn, queueOptions) {
    var _this = this;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const queuedRequest = _this.run(() => {
        fn(...args);
        queueMicrotask(() => queuedRequest.done());
        return () => {
        };
      }, queueOptions);
      return {
        abortOn,
        abort() {
          queuedRequest.abort();
        }
      };
    };
  }
  wrapPromiseFunction(fn, queueOptions) {
    var _this2 = this;
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      let queuedRequest;
      const outerPromise = new Promise((resolve, reject) => {
        queuedRequest = _this2.run(() => {
          let cancelError;
          let innerPromise;
          try {
            innerPromise = Promise.resolve(fn(...args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }
          innerPromise.then((result) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, (err) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return (cause) => {
            cancelError = createCancelError(cause);
          };
        }, queueOptions);
      });
      outerPromise.abort = (cause) => {
        queuedRequest.abort(cause);
      };
      outerPromise.abortOn = abortOn;
      return outerPromise;
    };
  }
  resume() {
    _classPrivateFieldLooseBase3(this, _paused)[_paused] = false;
    clearTimeout(_classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer]);
    for (let i = 0; i < this.limit; i++) {
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    }
  }
  /**
   * Freezes the queue for a while or indefinitely.
   *
   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.
   *                                    If omitted, the queue won't resume automatically.
   */
  pause(duration) {
    if (duration === void 0) {
      duration = null;
    }
    _classPrivateFieldLooseBase3(this, _paused)[_paused] = true;
    clearTimeout(_classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer]);
    if (duration != null) {
      _classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _resume)[_resume], duration);
    }
  }
  /**
   * Pauses the queue for a duration, and lower the limit of concurrent requests
   * when the queue resumes. When the queue resumes, it tries to progressively
   * increase the limit in `this.#increaseLimit` until another call is made to
   * `this.rateLimit`.
   * Call this function when using the RateLimitedQueue for network requests and
   * the remote server responds with 429 HTTP code.
   *
   * @param {number} duration in milliseconds.
   */
  rateLimit(duration) {
    clearTimeout(_classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer]);
    this.pause(duration);
    if (this.limit > 1 && Number.isFinite(this.limit)) {
      _classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] = this.limit - 1;
      this.limit = _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit];
      _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], duration);
    }
  }
  get isPaused() {
    return _classPrivateFieldLooseBase3(this, _paused)[_paused];
  }
};
function _call2(fn) {
  _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] += 1;
  let done = false;
  let cancelActive;
  try {
    cancelActive = fn();
  } catch (err) {
    _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
    throw err;
  }
  return {
    abort: (cause) => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
      cancelActive(cause);
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    },
    done: () => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    }
  };
}
function _queueNext2() {
  queueMicrotask(() => _classPrivateFieldLooseBase3(this, _next)[_next]());
}
function _next2() {
  if (_classPrivateFieldLooseBase3(this, _paused)[_paused] || _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] >= this.limit) {
    return;
  }
  if (_classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].length === 0) {
    return;
  }
  const next = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].shift();
  const handler = _classPrivateFieldLooseBase3(this, _call)[_call](next.fn);
  next.abort = handler.abort;
  next.done = handler.done;
}
function _queue2(fn, options) {
  if (options === void 0) {
    options = {};
  }
  const handler = {
    fn,
    priority: options.priority || 0,
    abort: () => {
      _classPrivateFieldLooseBase3(this, _dequeue)[_dequeue](handler);
    },
    done: () => {
      throw new Error("Cannot mark a queued request as done: this indicates a bug");
    }
  };
  const index = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].findIndex((other) => {
    return handler.priority > other.priority;
  });
  if (index === -1) {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].push(handler);
  } else {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);
  }
  return handler;
}
function _dequeue2(handler) {
  const index = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);
  if (index !== -1) {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
  }
}
var internalRateLimitedQueue = Symbol("__queue");

// node_modules/@uppy/utils/lib/fileFilters.js
function filterNonFailedFiles(files) {
  const hasError = (file) => "error" in file && file.error;
  return files.filter((file) => !hasError(file));
}
function filterFilesToEmitUploadStarted(files) {
  return files.filter((file) => !file.progress.uploadStarted || !file.isRestored);
}

export {
  UploaderPlugin,
  emitSocketProgress_default,
  getSocketHost,
  EventManager,
  isNetworkError_default,
  RateLimitedQueue,
  internalRateLimitedQueue,
  filterNonFailedFiles,
  filterFilesToEmitUploadStarted
};
//# sourceMappingURL=chunk-RQNNSFV7.js.map
